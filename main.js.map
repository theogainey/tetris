{
  "version": 3,
  "sources": ["src/utility.ts", "src/constants.ts", "src/update.ts", "src/render.ts", "src/eventListeners.ts", "src/index.ts"],
  "sourcesContent": ["export function randomTetromino() {\n  const tetrominos:TetrominoTypes[] = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];\n  const rand = Math.floor(Math.random() * tetrominos.length); \n  return tetrominos[rand];\n}\n", "import { randomTetromino } from \"./utility\";\n\nexport const tetrominoSize = 30;\nexport const gravity = 48; // frames it takes to fall 1 line;\n\nexport const tetrominos: Record<TetrominoTypes, TetrominoTypeDetails> = {\n  I: {\n    color: '#6EECEE',\n    offsets: [[0,0], [tetrominoSize, 0],  [tetrominoSize * 2, 0],  [tetrominoSize * 3, 0]],\n    rightExtreme: tetrominoSize * 4,\n    downExtreme: tetrominoSize,\n    vertices: [[0,0], [0, tetrominoSize], [tetrominoSize * 4, tetrominoSize],  [tetrominoSize * 4, 0]]\n  },\n  J: {\n    color: '#0000E6',\n    offsets: [[0,0], [0, tetrominoSize],  [tetrominoSize, tetrominoSize],  [tetrominoSize * 2, tetrominoSize]],\n    rightExtreme: tetrominoSize * 3,\n    downExtreme: tetrominoSize * 2,\n    vertices: [[0,0], [0, tetrominoSize * 2], [tetrominoSize * 3, tetrominoSize * 2], [tetrominoSize * 3, tetrominoSize], [tetrominoSize, tetrominoSize], [0, tetrominoSize]],\n  },\n  L: {\n    color: '#E4A439',\n    offsets: [[tetrominoSize * 2,0], [0, tetrominoSize],  [tetrominoSize, tetrominoSize],  [tetrominoSize * 2, tetrominoSize]],\n    rightExtreme: tetrominoSize * 3,\n    downExtreme: tetrominoSize * 2,\n    vertices: [[tetrominoSize * 2, 0], [tetrominoSize * 3, 0], [tetrominoSize * 3, tetrominoSize * 2], [0, tetrominoSize * 2], [0, tetrominoSize], [tetrominoSize * 2, tetrominoSize]],\n  },\n  O: {\n    color: '#E3E34B',\n    offsets: [[0,0], [0, tetrominoSize],  [tetrominoSize, 0],  [tetrominoSize, tetrominoSize]],\n    rightExtreme: tetrominoSize * 2,\n    downExtreme: tetrominoSize * 2,\n    vertices: [[0, 0], [0, tetrominoSize * 2], [tetrominoSize * 2, tetrominoSize * 2], [tetrominoSize * 2, 0],],\n  },\n  S: {\n    color: '#6EEC47',\n    offsets: [[tetrominoSize * 2, 0], [tetrominoSize, 0],  [tetrominoSize, tetrominoSize],  [0, tetrominoSize]],\n    rightExtreme: tetrominoSize * 2,\n    downExtreme: tetrominoSize * 2,\n    vertices: [[0, tetrominoSize], [0, tetrominoSize * 2], [tetrominoSize * 2, tetrominoSize * 2], [tetrominoSize * 2, tetrominoSize],[tetrominoSize * 3, tetrominoSize], [tetrominoSize * 3, 0],  [tetrominoSize, 0],   [tetrominoSize, tetrominoSize]],\n  },\n  T: {\n    color: '#921CE7',\n    offsets: [[tetrominoSize, 0], [tetrominoSize, tetrominoSize],  [0, tetrominoSize],  [tetrominoSize * 2, tetrominoSize]],\n    rightExtreme: tetrominoSize * 3,\n    downExtreme: tetrominoSize * 2,\n    vertices: [[tetrominoSize, 0], [tetrominoSize, tetrominoSize], [0, tetrominoSize], [0, tetrominoSize  * 2],[tetrominoSize * 3, tetrominoSize * 2], [tetrominoSize * 3, tetrominoSize],  [tetrominoSize * 2, tetrominoSize],   [tetrominoSize * 2, 0]],\n  },\n  Z: {\n    color: '#DC2F21',\n    offsets: [[0, 0], [tetrominoSize, 0],  [tetrominoSize, tetrominoSize],  [tetrominoSize * 2, tetrominoSize]],\n    rightExtreme: tetrominoSize * 3,\n    downExtreme: tetrominoSize * 2,\n    vertices: [[0, 0], [0, tetrominoSize], [tetrominoSize, tetrominoSize], [tetrominoSize, tetrominoSize  * 2],[tetrominoSize * 3, tetrominoSize * 2], [tetrominoSize * 3, tetrominoSize],  [tetrominoSize * 2, tetrominoSize],   [tetrominoSize * 2, 0]],\n  },\n}\n\nexport const canvas = document.getElementById(\"myCanvas\") as HTMLCanvasElement;\n\n\n// gameState\nexport const gameState: GameState = {\n  xCurrent: 0,\n  yCurrent: 0, \n  typeCurrent: randomTetromino(),\n  dy: tetrominoSize/gravity,\n  lockedTetrominos: [],\n  lockedCells: [],\n  collisionPath: new Map(),\n};\n", "import { tetrominos, tetrominoSize, gameState } from \"./constants\";\nimport { randomTetromino } from './utility'\n// if y value is small than smallest y at x point in collision point then no collision is possible even with a jagged path\n// returns true if no collision\nfunction minCollisionCheck(y: number, yCollisionPoints: number[]) {\n  const minY = Math.min(...yCollisionPoints)\n  return y < minY;\n}\n\nfunction noVerticalCollisionCheck() {\n  const {offsets} = tetrominos[gameState.typeCurrent]; \n  const potentialCollisionPoints = offsets.map(([xOffset, yOffset]) => ({\n    y: yOffset + tetrominoSize + gameState.yCurrent,\n    xStart: xOffset + gameState.xCurrent,\n    xEnd: xOffset + tetrominoSize + gameState.xCurrent,\n  }));\n  return potentialCollisionPoints.every(({xStart, xEnd, y}) => {\n    // right now this assumes no jagged stacks. Fix this next\n    const xStartCollisionPoints =  gameState.collisionPath.get(xStart) ?? [tetrominoSize * 20];    \n    const xEndCollisionPoints =  gameState.collisionPath.get(xEnd) ?? [tetrominoSize * 20];    \n    const matchingLedges = xStartCollisionPoints.filter((x) => xEndCollisionPoints.includes(x));\n    return minCollisionCheck(y, matchingLedges) // || jagged check\n  })\n};\n\nexport default function update():void{    \n  if(noVerticalCollisionCheck()) {    \n    gameState.yCurrent = gameState.yCurrent + gameState.dy; \n    return;\n  };\n\n  // if hitting floor add to cells\n  tetrominos[gameState.typeCurrent].offsets.forEach(([xOffset, yOffset]) => {\n    gameState.lockedCells.push({\n      color: tetrominos[gameState.typeCurrent].color,\n      xStart: gameState.xCurrent + xOffset,\n      yStart: gameState.yCurrent + yOffset,\n    });\n  });\n  \n  // //add to collisionPath \n  tetrominos[gameState.typeCurrent].offsets.forEach(([x, y]) => {\n    const yStartPoints = gameState.collisionPath.get(x + gameState.xCurrent);\n    const yEndPoints = gameState.collisionPath.get(x + tetrominoSize + gameState.xCurrent);\n    yStartPoints \n    ? gameState.collisionPath.set(x + gameState.xCurrent, yStartPoints.concat(y + gameState.yCurrent))\n    : gameState.collisionPath.set(x + gameState.xCurrent, [y + gameState.yCurrent])\n    yEndPoints \n    ? gameState.collisionPath.set(x + tetrominoSize + gameState.xCurrent, yEndPoints.concat(y + gameState.yCurrent))\n    : gameState.collisionPath.set(x + tetrominoSize + gameState.xCurrent, [y + gameState.yCurrent])\n  })\n\n  // start new block \n  gameState.xCurrent = 0;\n  gameState.yCurrent = 0;\n  gameState.typeCurrent = randomTetromino();\n};\n", "import { tetrominos, tetrominoSize, gameState, canvas } from \"./constants\";\n\nfunction drawCell(ctx: CanvasRenderingContext2D, color: string, xStart:number, yStart: number) {\n    ctx.beginPath();\n    ctx.rect(xStart, yStart, tetrominoSize, tetrominoSize);\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath(); \n}\n\nfunction drawTetromino(ctx: CanvasRenderingContext2D, type: TetrominoTypeDetails, x:number, y: number) {\n  type.offsets.forEach(([xOffset, yOffset])=>{\n    drawCell(ctx, type.color, x + xOffset, y + yOffset)\n  })\n}\n\n\nexport default function render() {\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  drawTetromino(ctx, tetrominos[gameState.typeCurrent], gameState.xCurrent, gameState.yCurrent);\n  \n  gameState.lockedCells.forEach(({color, xStart, yStart})=> {\n    drawCell(ctx, color, xStart, yStart);\n  });\n};\n", "import { tetrominoSize, gameState, tetrominos } from \"./constants\";\n\n\nfunction wallCheck(key: string ):boolean{\n  switch (key) {\n    case 'ArrowRight':\n      return (gameState.xCurrent + tetrominos[gameState.typeCurrent].rightExtreme < tetrominoSize * 10)\n    case 'ArrowLeft' :\n      return (gameState.xCurrent - tetrominoSize >= 0)\n    default:\n      return false;\n  }\n};\n\nfunction horizontalMove(key: string):void {\n  switch (key) {\n    case 'ArrowRight':\n      gameState.xCurrent = gameState.xCurrent + tetrominoSize;\n      break;\n    case 'ArrowLeft' :\n      gameState.xCurrent = gameState.xCurrent - tetrominoSize\n      break;\n    default:\n      gameState.xCurrent = gameState.xCurrent - tetrominoSize; \n      break;\n  }\n\n}\nexport default function eventListeners() {\n  window.addEventListener(\"keydown\", (event) => {\n    if(wallCheck(event.key)){\n      horizontalMove(event.key);\n    }\n  });\n};\n", "import update from './update';\nimport render from './render';\nimport eventListeners from './eventListeners';\n\nfunction main() {\n  window.requestAnimationFrame(main);\n  update();\n  render();\n}\n\neventListeners();\nmain();\nexport {};"],
  "mappings": "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",
  "names": ["randomTetromino", "tetrominos", "rand", "tetrominoSize", "gravity", "tetrominos", "canvas", "gameState", "randomTetromino", "minCollisionCheck", "y", "yCollisionPoints", "minY", "noVerticalCollisionCheck", "offsets", "tetrominos", "gameState", "xOffset", "yOffset", "tetrominoSize", "xStart", "xEnd", "_a", "_b", "xStartCollisionPoints", "xEndCollisionPoints", "matchingLedges", "x", "update", "yStartPoints", "yEndPoints", "randomTetromino", "drawCell", "ctx", "color", "xStart", "yStart", "tetrominoSize", "drawTetromino", "type", "x", "y", "xOffset", "yOffset", "render", "canvas", "tetrominos", "gameState", "wallCheck", "key", "gameState", "tetrominos", "tetrominoSize", "horizontalMove", "eventListeners", "event", "main", "update", "render", "eventListeners"]
}
